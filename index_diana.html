<!DOCTYPE html>
<html lang="en">
<head>
	<title>DIANA</title>
	<meta charset="utf-8">
	<meta content="text/html;charset=utf-8" http-equiv="Content-Type">
	<meta content="utf-8" http-equiv="encoding">
	<meta http-equiv="X-UA-Compatible" content="IE=11,chrome=1">
	<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
	<meta property="og:image" content="http://lo-th.github.io/olympe/res/img/logo.png"/>
	<meta property="og:title" content="Advanced Morphing"/>
	<meta property="og:url" content="http://lo-th.github.io/olympe/"/>
	<meta property="og:site_name" content="LOTH"/>
	<meta property="og:type" content="website"/>
	<meta property="og:description" content="Experiment full morphing in webGl"/>
	<meta name="language" content="en-us" />
	<link rel="shortcut icon" href="res/img/favicon.ico" type="image/x-icon" />
	<link href="css/dianna.css" rel="stylesheet" type="text/css">
	<link rel="stylesheet" type="text/css" href="history/history.css" />

</head>

	<script src="js/three.min.66.js"></script>
	<script src="js/BufferGeometryUtils.66.js"></script>

	<script src="js/Bvh.js"></script>

	<script src="js/loadersNew/sea3d/SEA.js"></script>
	<script src="js/loadersNew/sea3d/SEA3D.js"></script>
	<script src="js/loadersNew/sea3d/SEA3DLoader.js"></script>
	<script src="js/loadersNew/sea3d/SEA3DDeflate.js"></script>
	<script src="js/loadersNew/sea3d/SEA3DLZMA.js"></script>

	<script src="js/postprocessing/EffectComposer.js"></script>
	<script src="js/postprocessing/RenderPass.js"></script>
	<script src="js/postprocessing/ShaderPass.js"></script>
	<script src="js/postprocessing/BloomPass.js"></script>
	<script src="js/postprocessing/MaskPass.js"></script>
	<script src="js/postprocessing/BokehPass.js"></script>

	<script src="js/shaders/CopyShader.js"></script>
	<script src="js/shaders/FresnelShader.js"></script>
	<script src="js/shaders/ColorCorrectionShader.js"></script>
	<script src="js/shaders/VignetteShader.js"></script>
	<script src="js/shaders/SepiaShader.js"></script>
	<script src="js/shaders/BleachBypassShader.js"></script>
	<script src="js/shaders/ColorifyShader.js"></script>
	<script src="js/shaders/ConvolutionShader.js"></script>
	<script src="js/shaders/HorizontalBlurShader.js"></script>
	<script src="js/shaders/VerticalBlurShader.js"></script>
	<script src="js/postprocessing/TexturePass.js"></script>
	<script src="js/shaders/BokehShader.js"></script>

	<script src="js/ShaderSkin.js"></script>

	<script src="js/shaders/EyeShader.js"></script>
	
	<script src='js/libs/dat.gui.min.js'></script>
	<!--<script src="js/libs/tween.min.js"></script>-->
	<script src="js/tweenLite.min.js"></script>


	<script src="js/libs/jquery-1.9.1.min.js"></script>
	<script src="js/vendor/underscore.min.js"></script>
	<script src="js/vendor/app.js"></script>

	<script src="js/speak/speakClient.js"></script>

	<script>
		var vsize = { x:100, y:100, z:0 };
		var mouse = { x:0, y:0 };
		var lightPos, camPos;

		var inRender = true, inResize = false, isNeedPause = false;
		var FAR = 2000;

		var ToRad = Math.PI / 180;
		var ToDeg = 180 / Math.PI;

		var camera, container, scene, renderer, composer, renderPass, delta, center, centerLight;
		var ambient, hemiLight, pointLight, light;
		var body, suit, bodyNeck, bodyHead, head, neck, hair, eyeR, eyeL, teethUp, teethDown, eyeTop, tongue, troat, headBase, fakeNeck, eyesTarget;
		var eyeGeoL, eyeGeoR;
		var eyeMaterial;
		var materials = []; 
		var clock = new THREE.Clock();
		var ground;

		var gui;
		var animConfig = {
			current:"none",
			//neckmove:false, 
			idle:false,
			walk:true,
			salut:false,
			speed:0.8
		}

		var bobsAnim = {
			low:0
		}

		var morphConfig = {
			naked:false,
			bobs:50,
			automove:false,
			sadness: 0, anger: 0, joy: 0, fear: 0, disgust: 0, surprise: 0, blowing: 0,
			aah: 0, bigaah: 0, ch_j_sh: 0, f_v: 0, i: 0, k: 0, ee: 0,
			b_m_p: 0, n: 0, oh: 0, r: 0, d_s_t: 0, th: 0, w: 0, eh: 0, ooh_q:0
		};

		var voiceConfig = {
			googleVoise : false,
			rate: 120//, wordgap: 0, pitch: 230, speed: 100 
		};

		var viewConfig = {
			headMove: true,
			squeleton:false,
			antialias:false,
			withEffect:false,
			withNormal:false,
			withBump:true
		};

		var eyeController  = {
			pupil_size: 0.2,
			iris_tex_start: 0.009,
			iris_tex_end: 0.13,
			iris_border: 0.001,
			iris_size: 0.52,
			iris_edge_fade: 0.04,
			iris_inset_depth: 0.03,
			sclera_tex_scale: -0.14,
			sclera_tex_offset: 0.04,
			ior: 1.3,
			refract_edge_softness: 0.1,

			iris_texture_curvature: 0.51,
			arg_iris_shading_curvature: 0.51,

			tex_U_offset: 0.25,
			cornea_bump_amount: 0.1,
			cornea_bump_radius_mult: 0.9,
			iris_normal_offset: 0.001,
			cornea_density: 0.001,
			bump_texture: 0.3,
			catshape: false,
			col_texture: true
		};

		var effectController  = {
			DOF: false,
			exposure: 	1.0,
			focus: 		1.0,
			aperture:	0.025,
			maxblur:	1.0
		};

		var postprocessing = { enabled  : false };

		var sky;
		var skyCube;

		var imput, output, oldOutput;
		var text;
		var audio;
		var phonemesSequency;
		var tweenSequencyOpen, tweenSequencyClose;
		var suitAnim, bodyAnim, shadAnim;

		var playButton = document.getElementById('play');

		var morphsTables = [];
		var currentColors;
		var tweenSequencyEye = [];
		var tweenSequencyHair = [];
		var myHairTimer;
		var myEyeTimer;
		var eyes=[];
		var isSongTest = false;
		var soundSpeak;
		var oldSound="";
		var timeWav, timeProcess, timeComplete;
		var processTimer;

		var seq = { phoneme:0, control:0 };
		var tweenSequencyStart;

		var debug;

		var bvhReader = null;

		var displayModel = true;
		var squeleton;
		var bonesReference = [];


		var SeaStandard = true;
		var BonesRevers = false;
		var out2;


		function init() {

			if(ua.is.chrome)voiceConfig.googleVoise = true;

			vsize.x = window.innerWidth;
			vsize.y = window.innerHeight;
			vsize.z = vsize.x / vsize.y;

			camPos = { horizontal: 90, vertical: 80, distance: 100, automove: false };
			lightPos = { horizontal: 115, vertical: 35, distance: 200 };
            mouse = { ox:0, oy:0, h:0, v:0, mx:0, my:0, down:false, over:false, moving:true, dx:0, dy:0 };

            if(SeaStandard){
            	lightPos.horizontal+=180;
            	camPos.horizontal+=180;
            }

            out2 = document.getElementById("output2");

			imput = document.getElementById("editor");
			output = document.getElementById("output");
			oldOutput = document.getElementById("oldOutput");
			playButton = document.getElementById('play');
			playButton.style.visibility = 'hidden';

			debug = document.getElementById("debug");

			addGUI(); 
			addGUIVoise();
			addGUIView();

			initScene3D();
		}

		function debugTell(s) {
			debug.innerHTML = s;
		}

		function initScene3D() {
			
			// RENDERER
			renderer = new THREE.WebGLRenderer({  antialias: false });
			renderer.setSize( vsize.x, vsize.y );
			renderer.autoClear = false;
			//renderer.sortObjects = false;
			renderer.gammaInput = true;
			renderer.gammaOutput = true;
			renderer.shadowMapEnabled = true;
			//renderer.shadowMapCullFace = THREE.CullFaceBack;
			renderer.shadowMapType = THREE.PCFSoftShadowMap;

			container = document.getElementById("viewport");
            container.appendChild( renderer.domElement );
			renderer.domElement.style.top = 0 + "px";
			renderer.domElement.style.left = 0 + "px";
			renderer.domElement.style.position = "absolute";

			// SCENE
			scene = new THREE.Scene();

			// CAMERA
			camera = new THREE.PerspectiveCamera( 45, vsize.z, 1, FAR );
		    center = new THREE.Vector3();
		    centerLight =  new THREE.Vector3(0,-36.6,0);
		    moveCamera();


			initPostprocessing();

			addBasicObject();

			initLightAndSky();

			initMaterial();

			importBody();

			window.addEventListener( 'resize', resize, false );
			container.addEventListener( 'mousemove', onMouseMove, false );
		    container.addEventListener( 'mousedown', onMouseDown, false );
		    container.addEventListener( 'mouseout', onMouseUp, false );
		    container.addEventListener( 'mouseup', onMouseUp, false );

		    var body = document.body;
		    if( body.addEventListener ){
		        body.addEventListener( 'mousewheel', onMouseWheel, false ); //chrome
		        body.addEventListener( 'DOMMouseScroll', onMouseWheel, false ); // firefox
		    }else if( body.attachEvent ){
		        body.attachEvent("onmousewheel" , onMouseWheel); // ie
		    }
		    animate();
		}

		function postChanger( ) {	
			postprocessing.enabled = effectController.DOF;
			/*postprocessing.colcor.uniforms[ "mulRGB" ].value =  new THREE.Vector3( effectController.exposure, effectController.exposure, effectController.exposure );
			postprocessing.bokeh.uniforms[ "focus" ].value = effectController.focus;
			postprocessing.bokeh.uniforms[ "aperture" ].value = effectController.aperture;
			postprocessing.bokeh.uniforms[ "maxblur" ].value = effectController.maxblur;*/
		};

		//-----------------------------------------------------
		//
		//  RENDER LOOP
		//
		//-----------------------------------------------------

		function animate() {
			
			requestAnimationFrame( animate );
			render();
		}

		function render() {
			delta = clock.getDelta();

			updateBVH();

			THREE.AnimationHandler.update( delta*animConfig.speed );

			var time = Date.now() * 0.001;
			if(eyeMaterial)eyeMaterial.uniforms.pupil_size.value = 0.2 * Math.sin( 0.5 * time ) + 0.3;

			//TWEEN.update();

			// create morph sequence if change
			countWords();

			if(isSongTest) songReady();

			// sea update
			if(head && bodyNeck){
				var mtx = bodyNeck.matrixWorld;
                head.position.setFromMatrixPosition( mtx );
                head.position.y +=0.2;
                head.position.z +=0.3;


                var ref0 = body.bones[17].rotation;
                var ref1 = body.bones[20].rotation;
                
                head.bones[0].rotation.set(ref0.y, -ref0.x, -ref0.z+(90*ToRad));

                if(viewConfig.headMove) head.bones[1].rotation.set(ref1.x+((12-(mouse.dx*0.5))*ToRad), -ref1.y+((10-(mouse.dy*0.5))*ToRad), -ref1.z);
                else head.bones[1].rotation.set(ref1.x, -ref1.y, -ref1.z);
			}

			renderer.clear();


			// render update
			if(postprocessing.enabled) postprocessing.composer.render(0.1);
			else if(renderer) renderer.render( scene, camera );
		}

		//-----------------------------------------------------
		//  LISTENER
		//-----------------------------------------------------

		function onMouseMoveExtra( e ) {
			

			// eye look
			if(eyesTarget){
				mouse.dx = (mouse.ox - window.innerWidth*0.5)*0.1;
				mouse.dy = -(mouse.oy - window.innerHeight*0.5)*0.1
				eyesTarget.position.set( mouse.dx, mouse.dy, 50 );
				var pos = new THREE.Vector3( - eyesTarget.position.y +100, eyesTarget.position.x+0.2, eyesTarget.position.z);
				var pos2 = new THREE.Vector3( - eyesTarget.position.y +100, eyesTarget.position.x-0.2, eyesTarget.position.z);
				eyeR.lookAt(pos);
				eyeL.lookAt(pos2);
		    }


			// change morph weight
			if(morphConfig.automove){
				fullMorph("smileOpen", mouse.ox / vsize.x );
				fullMorph("fear", mouse.oy / vsize.y);
			}
		}

		function resize( event ) {

			vsize.x = window.innerWidth;
			vsize.y = window.innerHeight;
			vsize.z = vsize.x / vsize.y;

			camera.aspect = vsize.z;
			camera.updateProjectionMatrix();
			renderer.setSize( vsize.x, vsize.y );
			if(postprocessing.enabled)postprocessing.composer.setSize( vsize.x, vsize.y );
		}



		//-----------------------------------------------------
		//  LIGHT & SKY
		//-----------------------------------------------------

		function initLightAndSky(){

			ambient = new THREE.AmbientLight( 0x202020 );
			scene.add( ambient );

			hemiLight = new THREE.HemisphereLight( 0x202020, 0xffffff, 1 );
			hemiLight.position.set( 0, 20, 0 );
			scene.add( hemiLight );

			pointLight = new THREE.PointLight( 0xFFFFFF, 1, 600 );
			scene.add( pointLight );

			light = new THREE.SpotLight( 0xFFFFFF, 1, 0, Math.PI/2, 1 );
			light.castShadow = true;
			light.onlyShadow = false;
			light.shadowCameraNear = 50;
			light.shadowCameraFar = 500;
			//light.shadowCameraFov = 35;
			light.shadowBias = -0.005;
			light.shadowMapWidth = light.shadowMapHeight = 1024;
			light.shadowDarkness = 0.35;

			moveLight();
			
			//light.shadowCameraVisible = true; 

			scene.add( light );

			// SKYBOX
			addSkyBox();

		}	

		function moveLight() {
		    light.position.copy(Orbit(centerLight, lightPos.horizontal, lightPos.vertical, lightPos.distance));
		    pointLight.position.copy(Orbit(centerLight, lightPos.horizontal+180, lightPos.vertical+180, lightPos.distance));
		    light.lookAt(centerLight);
		}
		
		function lightColors( cc ){
			ambient.color.setHex(cc[2]);

			hemiLight.color.setHex( cc[2] );
			hemiLight.groundColor.setHex( cc[0] );

			pointLight.color.setHex( cc[1] );

			light.color.setHex( cc[3] );

			currentColors = cc;
		}

		function addBasicObject() {
			var skyMaterial = new THREE.MeshBasicMaterial( { color: 0x262626, side: THREE.BackSide, depthWrite: false } );
		    sky = new THREE.Mesh( new THREE.BoxGeometry( FAR, FAR, FAR ), skyMaterial );
			scene.add( sky );

			var groundMaterial = new THREE.MeshBasicMaterial( { color: 0xFFFFFF, transparent: true } );
			var blendings = [ "NoBlending", "NormalBlending", "AdditiveBlending", "SubtractiveBlending", "MultiplyBlending", "AdditiveAlphaBlending" ];
			groundMaterial.blending = THREE[ blendings[ 4 ] ];
			
			ground = new THREE.Mesh(new THREE.PlaneGeometry( 1000, 1000, 4, 4 ), groundMaterial);
			ground.position.set( 0, -36.6, 0 );
			ground.rotation.x = - Math.PI / 2;
			ground.receiveShadow = true;
			scene.add( ground );
		}

		function addSkyBox() {
			var cubes = [2, 14, 26, 30,31,32,33];
			var cubesColors = [  
			    [ 0x7683ad, 0xc6cfde, 0x5868bd, 0xfafafa ], [ 0x45473c, 0xa1a4a9, 0x757a80, 0xffffff ], 
			    [ 0x102540, 0xcc8cea, 0x6b7d7f, 0xf8f8f8 ], [ 0x6d6c7a, 0x9b8379, 0x6f7488, 0xffffd9 ],
				[ 0x5f5e6e, 0xeec87f, 0x7390ba, 0xfdfeec ], [ 0xd7ccb0, 0xcecfc9, 0x77819a, 0xffffff ], 
				[ 0x908c81, 0xd5c298, 0x718095, 0xfffffb] 
			];
			var n = Math.floor(Math.random()*cubes.length);
			lightColors( cubesColors[n] );

			var format = ".jpg";
			var r = "res/textures/cube/sky"+cubes[n]+"/";
			var urls = [ r + "posx"+format, r + "negx"+format,
						 r + "posy"+format, r + "negy"+format,
						 r + "posz"+format, r + "negz"+format ];

			skyCube = THREE.ImageUtils.loadTextureCube( urls );
			skyCube.format = THREE.RGBFormat;
			var shader = THREE.ShaderLib[ "cube" ];
			shader.uniforms[ "tCube" ].value = skyCube;

			var material = new THREE.ShaderMaterial( {
				fragmentShader: shader.fragmentShader,
				vertexShader: shader.vertexShader,
				uniforms: shader.uniforms,
				depthWrite: false,
				side: THREE.BackSide
			});

			sky.material = material;
		}

		//-----------------------------------------------------
		//  COMPOSER
		//-----------------------------------------------------

		function initPostprocessing(){
			var renderPass = new THREE.RenderPass( scene, camera );
			//var effectBeckmann = new THREE.ShaderPass( THREE.ShaderSkin[ "beckmann" ] );
			//var effectCopy = new THREE.ShaderPass( THREE.CopyShader );
			//effectCopy.renderToScreen = true;
			/*var bokehPass = new THREE.BokehPass( scene, camera, {
				focus: 		1.0,
				aperture:	0.025,
				maxblur:	1.0,

				width: vsize.x,
				height: vsize.y
			} );

			bokehPass.renderToScreen = true;*/
			
			var colorCorrectionPass = new THREE.ShaderPass( THREE.ColorCorrectionShader );
			colorCorrectionPass.uniforms[ "powRGB" ].value = new THREE.Vector3( 1.0, 1.0, 1.0 );
			colorCorrectionPass.uniforms[ "mulRGB" ].value = new THREE.Vector3( 1.0, 1.0, 1.0 );
			
			var composer = new THREE.EffectComposer( renderer );

			composer.addPass( renderPass );
			//composer.addPass( colorCorrectionPass );
			//composer.addPass( effectBeckmann );
		//	composer.addPass( effectCopy );

			//composer.addPass( bokehPass );
			
			postprocessing.composer = composer;
			//postprocessing.colcor = colorCorrectionPass;
			//postprocessing.bokeh = bokehPass;
			/*if(viewConfig.withEffect){

				composer = new THREE.EffectComposer( renderer );
				composer.addPass( new THREE.RenderPass( scene, camera ));
				
				var vh = 1.6, vl = 1.2;
				var mix =0.1;

				var colorCorrectionPass = new THREE.ShaderPass( THREE.ColorCorrectionShader );
				colorCorrectionPass.uniforms[ "powRGB" ].value = new THREE.Vector3( vh, vh, vh );
				colorCorrectionPass.uniforms[ "mulRGB" ].value = new THREE.Vector3( vl, vl, vl );
				composer.addPass( colorCorrectionPass );	

				var shaderSepia = THREE.SepiaShader;
				var effectSepia = new THREE.ShaderPass( shaderSepia );
				effectSepia.uniforms[ "amount" ].value =0.3;
				//effectSepia.renderToScreen = true;
				composer.addPass(effectSepia);

			//	var effectBloom = new THREE.BloomPass( 0.2, mix*25, mix*4.0  );
			//	composer.addPass( effectBloom );

				var vignettePass = new THREE.ShaderPass( THREE.VignetteShader );
				vignettePass.uniforms[ "offset" ].value = 1.5;
				vignettePass.uniforms[ "darkness" ].value = 1.0;
				composer.addPass( vignettePass );

				var copyPass = new THREE.ShaderPass( THREE.CopyShader );
				copyPass.renderToScreen = true;
				composer.addPass( copyPass );
			}*/

		}

		
		//-----------------------------------------------------
		//
		//  SEA3D IMPORT
		//
		//-----------------------------------------------------
		

		function importBody(){
			var loader = new THREE.SEA3D( SeaStandard );
			var dir;
			if(SeaStandard){
				dir = 1; 
				camera.scale.set(-1,1,1);
				ground.scale.set(-1,1,1);
				sky.scale.set(-1,1,1);
			}
			else {dir = -1}
			loader.onComplete = function( e ) {

				var geoSuit = loader.getMesh("Suit").geometry;
				var geoBody = loader.getMesh("Body").geometry;

				// base mesh
				body = new THREE.SkinnedMesh ( geoBody, materials[9] , false );
				body.scale.set( 1, 1, dir );
				scene.add( body );

				suit = new THREE.SkinnedMesh ( geoSuit, materials[1] , false );
				suit.scale.set( 1, 1, dir );
				scene.add( suit );

				// for shadow
				var mat  = new THREE.MeshBasicMaterial({skinning: true, transparent:true, opacity:0 });
				bodyShadow = new THREE.SkinnedMesh ( geoBody, mat , false );
				bodyShadow.scale.set( 1, 1, dir );
				scene.add( bodyShadow );

				// bone reference for head
				bodyNeck = new THREE.Object3D();
	            var bone = body.bones[17];
	            bodyNeck.matrix = bone.skinMatrix;
	            bodyNeck.matrixAutoUpdate = false;
	            body.add( bodyNeck );

	            bodyHead = new THREE.Object3D();
	            bone = body.bones[20];
	            bodyHead.matrix = bone.skinMatrix;
	            bodyHead.matrixAutoUpdate = false;
	            body.add( bodyHead );


				suit.castShadow = false;
				body.castShadow = false;
				bodyShadow.castShadow = true;
				suit.receiveShadow = true;
				body.receiveShadow = true;
				bodyShadow.receiveShadow = false;

				// animation
				bodyAnim = new SEA.Animator(body, "Body");
				bodyAnim.add("idle", true);
				bodyAnim.add("walk", true);
				bodyAnim.add("tell", true);
				bodyAnim.add("calibration", false);
				bodyAnim.add("boneref", false);

				suitAnim = new SEA.Animator(suit, "Body");
				suitAnim.add("idle", true);
				suitAnim.add("walk", true);
				suitAnim.add("tell", true);
				suitAnim.add("calibration", false);
				suitAnim.add("boneref", false);

				shadAnim = new SEA.Animator(bodyShadow, "Body");
				shadAnim.add("idle", true);
				shadAnim.add("walk", true);
				shadAnim.add("tell", true);
				shadAnim.add("calibration", false);
				shadAnim.add("boneref", false);

				playAnimation( "boneref" );
				stopAnimation();
				//

				// low breasts size
				bobsMorph(0.3);

				// bones TEST
				squeleton = new THREE.Object3D();
				squeleton.scale.set( 1, 1, dir );
				scene.add( squeleton );

				var nBone  
				var geoBone = new THREE.BoxGeometry( 1, 1, 1 );
				var geoBone2 = new THREE.BoxGeometry( 6, 3, 3 );
				geoBone2.applyMatrix( new THREE.Matrix4().makeTranslation( 3, 0, 0 ) );

				var matBone;
				var matBoneX = new THREE.MeshBasicMaterial( {color:0xff0000} );
				var matBone0 = new THREE.MeshBasicMaterial( {color:0xffff00} );
				var matBone2 = new THREE.MeshBasicMaterial( {color:0xff0000} );
				var matBone1 = new THREE.MeshBasicMaterial( {color:0x808080} );

				var matBoneR = new THREE.MeshBasicMaterial( {color:0x00ff00} );
				var matBoneR0 = new THREE.MeshBasicMaterial( {color:0x30ff30} );
				var matBoneR1 = new THREE.MeshBasicMaterial( {color:0x60ff60} );
				var matBoneR2 = new THREE.MeshBasicMaterial( {color:0x90ff90} );

				var matBoneL = new THREE.MeshBasicMaterial( {color:0x0000ff} );
				var matBoneL0 = new THREE.MeshBasicMaterial( {color:0x3030ff} );
				var matBoneL1 = new THREE.MeshBasicMaterial( {color:0x6060ff} );
				var matBoneL2 = new THREE.MeshBasicMaterial( {color:0x9090ff} );

				bonesNames = [
				    "Hips", "Spine1", "RightUpLeg", "LeftUpLeg", "RightLowLeg",
				    "Chest", "LeftLowLeg", "Spine3", "LeftFoot", "RightFoot",
				    "RightToe", "LeftCollar", "Chest2", "LeftToe", "RightCollar", 
				    "LeftUpArm", "RightUpArm", "Neck", "RightLowArm", "LeftLowArm" ,
				    "Head", "LeftLowArm2", "RightLowArm2", "RightHand", "LeftHand",

				    "FL00", "FR20", "FR00", "FL10", "FL40",
				    "FR40", "FL20", "FR10", "FR30", "FL30",

				    "FL31", "FR31", "FL11", "FL41", "FR21",
				    "FR41", "FR01", "FL01", "FL21", "FR11",

				    "FR12", "FR02", "FL42", "FR22", "FL32",
				    "FL22", "FR32", "FL12", "FL02", "FR42"
				];

				bonesNamesRevers = [
				    "Hips", "Spine1", "LeftUpLeg", "RightUpLeg", "LeftLowLeg",
				    "Chest", "RightLowLeg", "Spine3", "RightFoot", "LeftFoot",
				    "LeftToe", "RightCollar", "Chest2", "RightToe", "LeftCollar", 
				    "RightUpArm", "LeftUpArm", "Neck", "LeftLowArm", "RightLowArm" ,
				    "Head", "RightLowArm2", "LeftLowArm2", "LeftHand", "RightHand",

				    "FR00", "FL20", "FL00", "FR10", "FR40",
				    "FL40", "FR20", "FL10", "FL30", "FR30",

				    "FR31", "FL31", "FR11", "FR41", "FL21",
				    "FL41", "FL01", "FR01", "FR21", "FL11",

				    "FL12", "FL02", "FR42", "FL22", "FR32",
				    "FR22", "FL32", "FR12", "FR02", "FL42"
				];

				var bone;

				
				//suit.matrixWorldNeedsUpdate = false;

				for (var i=0, l=body.bones.length; i !== l; i++){

					bone = body.bones[i];
					if(BonesRevers) bone.name = bonesNamesRevers[i];
					else bone.name = bonesNames[i];

					if(i<25)bonesReference[i] = { name:bone.name, x:(bone.rotation.x*ToDeg).toFixed(2), y:(bone.rotation.y*ToDeg).toFixed(2), z:(bone.rotation.z*ToDeg).toFixed(2) }
					//console.log(bonesReference[i]);
					//suit.bones[i].name = bonesNames[i];

					//bone.rotation.order = 'ZXY';

					var axis = new THREE.AxisHelper(1);
					var addAxis;
		
	

					//if(!displayModel){
						addAxis = true;
						matBone = matBone1;
						var bn = bone.name.substring(0,2);
						var n = bone.name.substring(3,4);
						if(bn === "Le" || bn === "FL"){
							if(n==="0"){matBone = matBoneL0;addAxis=false;}
							else if(n==="1"){matBone = matBoneL1; addAxis=false;//bone.rotation.y = -45*ToRad;
							 }
							else if(n==="2"){matBone = matBoneL2;  addAxis=false;//bone.rotation.y = -45*ToRad;
							 }
						    else matBone = matBoneL;
						}
						else if(bn === "Ri" || bn === "FR"){ 
							if(n==="0"){matBone = matBoneR0;addAxis=false;}
							else if(n==="1"){matBone = matBoneR1; addAxis=false;//bone.rotation.y = -45*ToRad;
							 }
							else if(n==="2"){matBone = matBoneR2;  addAxis=false;//bone.rotation.y = -45*ToRad;
							 }
						    else matBone = matBoneR;
						}
						else{ matBone = matBone0; }

						// bone test
						if(i === 20){ nBone = new THREE.Mesh( geoBone2, matBone ); }
						else if(i === 0){ nBone = new THREE.Mesh( geoBone, matBoneX ); }
						else { nBone = new THREE.Mesh( geoBone, matBone ); }
						nBone.matrix = bone.skinMatrix;
						nBone.matrixAutoUpdate = false;
						//body.add( nBone );
						squeleton.add( nBone );
						if( addAxis ) nBone.add(axis)
						//
					//}

					// update bone
					//bone.matrixAutoUpdate = true;
			        //bone.matrixWorldNeedsUpdate = true;
				}

				modelOrBones();

				importHead();

					
				//bodyShadow.visible = false;
				//suit.visible = false;
				//document.getElementById('loading').style.visibility = 'hidden';	
				
				addGUIAnimation();

				playAnimation( "walk" );

				// BVH test
				initBVH();
		
			};
			
			loader.load( 'res/models/diana_body.sea' );

		}

		function modelOrBones() {
			var i;
			if(viewConfig.squeleton){
				if(head){
					head.visible = false;
					hair.visible = false;
					/*i = head.children.length;
					while (i--) {
						if(head.children[ i ].children.length !== 0) head.children[ i ].children[ 0 ].visible = false;
						head.children[ i ].visible = false;
					};*/
				}
				body.visible = false;
				suit.visible = false;
				bodyShadow.visible = false;
				i = squeleton.children.length;
				while (i--) {
					if(squeleton.children[ i ].children.length !== 0) squeleton.children[ i ].children[ 0 ].visible = true;
					squeleton.children[ i ].visible = true;
				};
				squeleton.visible = true;
			} else {
				if(head){
					head.visible = true;
					hair.visible = true;
				}
				body.visible = true;
				suit.visible = true;
				bodyShadow.visible = true;
				i = squeleton.children.length;
				while (i--) {
					if(squeleton.children[ i ].children.length !== 0) squeleton.children[ i ].children[ 0 ].visible = false;
					squeleton.children[ i ].visible = false;
				};
				squeleton.visible = false;
			}
		}

		//-----------------------------------------------------
		//  STANDARD ANIMATION
		//-----------------------------------------------------

		function playAnimation(name) {
			if(bvhReader){
				if(bvhReader.play) bvhReader.play = false;
				bvhReader.clearNode();
			}
			bodyAnim.play(name);
			suitAnim.play(name);
			shadAnim.play(name);
			animConfig.current = name;
			if(name ==="walk") bobsWalk();
		}

		function stopAnimation() {
			suitAnim.stop();
			bodyAnim.stop();
			shadAnim.stop();
			animConfig.current ="";
		}

		//-----------------------------------------------------
		//  BVH TEST
		//-----------------------------------------------------

		var BVHset = {ax:"z", ay:"y", az:"x", dx:1, dy:1, dz:1, rx:0, ry:0, rz:0, order:"ZXY"};
		var BVHanimConfig = {
			debug:true,
			speed:0.5
		}

		function initBVH() {
			bvhReader = new BVH.Reader();
			bvhReader.speed = BVHanimConfig.speed;

			initBVHGui();
			//initBoneTools();
		}

		function loadBVH(name) {
			stopAnimation();
			bvhReader.load("res/bvh/"+name);
		}

		var bonesConfig = {select: 1, X:0, Y:0, Z:0}

		function initBoneTools() {
			var f0 = gui.addFolder('Bones tool');
			f0.add( bonesConfig, 'select' ).step(1);
			f0.add( bonesConfig, 'X', -360, 360 ).onChange( moveBone );
			f0.add( bonesConfig, 'Y', -360, 360 ).onChange( moveBone );
			f0.add( bonesConfig, 'Z', -360, 360 ).onChange( moveBone );
		}
		function moveBone() {
			var n = bonesConfig.select || 0;
			body.bones[n].rotation.set(bonesConfig.X*ToRad, bonesConfig.Y*ToRad,bonesConfig.Z*ToRad);
			suit.bones[n].rotation.set(bonesConfig.X*ToRad, bonesConfig.Y*ToRad,bonesConfig.Z*ToRad);
			bodyShadow.bones[n].rotation.set(bonesConfig.X*ToRad, bonesConfig.Y*ToRad,bonesConfig.Z*ToRad);

			body.bones[n].matrixAutoUpdate = true;
			body.bones[n].matrixWorldNeedsUpdate = true;
		}


		function initBVHGui() {
			var f5 = gui.addFolder('BVH Animation BETA');
			
			f5.add( BVHanimConfig, 'debug' ).listen().onChange( function() {bvhReader.debug = this});

			

            BVHanimConfig.ballet = function() { loadBVH("ballet.png"); };
            BVHanimConfig.shoot = function() { loadBVH("shoot.png"); };
            BVHanimConfig.sprint = function() { loadBVH("sprint.png"); };
            BVHanimConfig.exsize = function() { loadBVH("exsize.png"); };
            BVHanimConfig.test = function() { loadBVH("test.png"); };
            BVHanimConfig.big = function() { loadBVH("big.png"); };
            BVHanimConfig.story = function() { loadBVH("story.png"); };
            BVHanimConfig.action = function() { loadBVH("action.png"); };

            BVHanimConfig.stop = function() {  bvhReader.play = false; };
            BVHanimConfig.play = function() { bvhReader.oldFrame = bvhReader.frame; bvhReader.startTime = Date.now(); bvhReader.play = true; };
            BVHanimConfig.next = function() { bvhReader.next(); };
            BVHanimConfig.prev = function() { bvhReader.prev(); };

            f5.add( BVHanimConfig, 'ballet' );
            f5.add( BVHanimConfig, 'shoot' );
            f5.add( BVHanimConfig, 'sprint' );
            f5.add( BVHanimConfig, 'exsize' );
            f5.add( BVHanimConfig, 'test' );
            f5.add( BVHanimConfig, 'big' );

            f5.add( BVHanimConfig, 'story' );
            f5.add( BVHanimConfig, 'action' );

            f5.add( BVHanimConfig, 'speed', 0.1, 1 ).onChange( function() { bvhReader.speed = BVHanimConfig.speed; });;

            f5.add( BVHanimConfig, 'stop' );
            f5.add( BVHanimConfig, 'play' )
            f5.add( BVHanimConfig, 'next' );
            f5.add( BVHanimConfig, 'prev' );


			f5.add( BVHset, 'ax', [ 'x', 'y', 'z' ] );
			f5.add( BVHset, 'ay', [ 'x', 'y', 'z' ] );
			f5.add( BVHset, 'az', [ 'x', 'y', 'z' ] );

			f5.add( BVHset, 'dx', [ 1, -1, 0 ] );
			f5.add( BVHset, 'dy', [ 1, -1, 0 ] );
			f5.add( BVHset, 'dz', [ 1, -1, 0 ] );

			f5.add( BVHset, 'rx', [ -270, -180, -90, 0, 90, 180, 270, 360 ] );
			f5.add( BVHset, 'ry', [ -270, -180, -90, 0, 90, 180, 270, 360 ] );
			f5.add( BVHset, 'rz', [ -270, -180, -90, 0, 90, 180, 270, 360 ] );

			


			//.onChange( function() { synthesis.rate = voiceConfig.rate/100 });
			/*f3.add( voiceConfig, 'wordgap', 0, 100 ).onChange( function() {});
			f3.add( voiceConfig, 'pitch', 0, 400 ).onChange( function() {});
			f3.add( voiceConfig, 'speed', 0, 400 ).onChange( function() {});*/

			f5.close();
			//f5.open();

		}

		function updateBVH() {
			

			if(bvhReader !== null && bvhReader.play){
				var tt="" 

				/*if(animConfig.current !== "custom" ){
					stopAnimation();
					animConfig.current = "custom";
				}*/


				//parseLine( count );
				//if ( ++count >= bvhReader.lines.length ) { count = 0; }	
				//} else { parseLine( count ); }

				bvhReader.update();
				//var maxNode = bvhReader.channels.length;
				var maxNode = bvhReader.nodes.length;
				var maxBone = 25;//body.bones.length;
				var bone, node, ref, i, j;
				var bone1, bone2


				for ( i=0; i < maxBone; i++){
					bone = body.bones[i];
					ref = bonesReference[i];
					bone1 = suit.bones[i];
					bone2 = bodyShadow.bones[i];

				    for (j=0; j<maxNode; j++){
				    	node = bvhReader.nodes[j];

						if(bone.name === node.name){
							if(i===0 && j===0){
							//if(bone.name=="Hips"){
								bone.position.copy( node.position );
								bone1.position.copy( node.position );
								bone2.position.copy( node.position );
							}

							/*	bone.rotation.set( node.rot.y, node.rot.x, -node.rot.z+(90*ToRad) );
								bone1.rotation.set( node.rot.y, node.rot.x, -node.rot.z+(90*ToRad) );
								bone2.rotation.set( node.rot.y, node.rot.x, -node.rot.z+(90*ToRad) );
							}else if(bone.name==="RightUpLeg" || bone.name==="LeftUpLeg" ){
								bone.rotation.set( node.rot.y, -node.rot.x, node.rot.z+(180*ToRad) );
								bone1.rotation.set( node.rot.y, -node.rot.x, node.rot.z+(180*ToRad) );
								bone2.rotation.set( node.rot.y, -node.rot.x, node.rot.z+(180*ToRad) );


							} else {*/
								

								/*bone.rotation.copy( node.rot );
								bone1.rotation.copy( node.rot );
								bone2.rotation.copy( node.rot );*/

							  // bone.rotation.set( node.rot.y, node.rot.x, node.rot.z );
								//bone1.rotation.set( node.rot.x, node.rot.y, node.rot.z+(90*ToRad) );
								//bone2.rotation.set( node.rot.x, node.rot.y, node.rot.z+(90*ToRad) );

								//bone.quaternion.set()

								/*bone.rotation.set( (node.rot[BVHset.ax]+(BVHset.rx*ToRad))*BVHset.dx,( node.rot[BVHset.ay]+(BVHset.ry*ToRad))*BVHset.dy, (node.rot[BVHset.az]+(BVHset.rz*ToRad))*BVHset.dz );
								bone1.rotation.set( (node.rot[BVHset.ax]+(BVHset.rx*ToRad))*BVHset.dx,( node.rot[BVHset.ay]+(BVHset.ry*ToRad))*BVHset.dy, (node.rot[BVHset.az]+(BVHset.rz*ToRad))*BVHset.dz );
								bone2.rotation.set( (node.rot[BVHset.ax]+(BVHset.rx*ToRad))*BVHset.dx,( node.rot[BVHset.ay]+(BVHset.ry*ToRad))*BVHset.dy, (node.rot[BVHset.az]+(BVHset.rz*ToRad))*BVHset.dz );*/

								//;
							//} else {
								//var r = new THREE.Euler( (node.rot[BVHset.ax]+(BVHset.rx*ToRad))*BVHset.dx, ( node.rot[BVHset.ay]+(BVHset.ry*ToRad))*BVHset.dy, (node.rot[BVHset.az]+(BVHset.rz*ToRad))*BVHset.dz , BVHset.order)
								/*var quat = new THREE.Quaternion();
								quat.setFromEuler(r);
								quat.normalize();
								bone.setRotationFromQuaternion(quat);
								bone1.setRotationFromQuaternion(quat);
								bone2.setRotationFromQuaternion(quat);*/
								//bone.rotation.order = BVHset.order;

								/*bone.setRotationFromEuler(r);
								bone1.setRotationFromEuler(r);
								bone2.setRotationFromEuler(r);*/
								bone.rotation.x = ((node.rotation[BVHset.ax]+(BVHset.rx*ToRad))*BVHset.dx)+(ref.x*ToRad);
								bone.rotation.y = ((node.rotation[BVHset.ay]+(BVHset.ry*ToRad))*BVHset.dy)+(ref.y*ToRad);
								bone.rotation.z = ((node.rotation[BVHset.az]+(BVHset.rz*ToRad))*BVHset.dz)+(ref.z*ToRad);
								
								
								

								/*bone.rotation.x = ((node.rot[BVHset.ax]+(BVHset.rx*ToRad))*BVHset.dx)+(ref[BVHset.ax]*ToRad);
								bone.rotation.y = ((node.rot[BVHset.ay]+(BVHset.ry*ToRad))*BVHset.dy)+(ref[BVHset.ay]*ToRad);
								bone.rotation.z = ((node.rot[BVHset.az]+(BVHset.rz*ToRad))*BVHset.dz)+(ref[BVHset.az]*ToRad);*/

								/*bone.rotation.x = (node.rot[BVHset.ax]+(BVHset.rx*ToRad))*BVHset.dx;
								bone.rotation.y = (node.rot[BVHset.ay]+(BVHset.ry*ToRad))*BVHset.dy;
								bone.rotation.z = (node.rot[BVHset.az]+(BVHset.rz*ToRad))*BVHset.dz;*/

							//}

							/*bone.rotation.set( (node.rot[BVHset.ax]+(BVHset.rx*ToRad))*BVHset.dx,( node.rot[BVHset.ay]+(BVHset.ry*ToRad))*BVHset.dy, (node.rot[BVHset.az]+(BVHset.rz*ToRad))*BVHset.dz );
								bone1.rotation.set( (node.rot[BVHset.ax]+(BVHset.rx*ToRad))*BVHset.dx,( node.rot[BVHset.ay]+(BVHset.ry*ToRad))*BVHset.dy, (node.rot[BVHset.az]+(BVHset.rz*ToRad))*BVHset.dz );
								bone2.rotation.set( (node.rot[BVHset.ax]+(BVHset.rx*ToRad))*BVHset.dx,( node.rot[BVHset.ay]+(BVHset.ry*ToRad))*BVHset.dy, (node.rot[BVHset.az]+(BVHset.rz*ToRad))*BVHset.dz );*/

							/*bone.setRotationFromEuler( node.rot )
							bone1.setRotationFromEuler( node.rot )
							bone2.setRotationFromEuler( node.rot )*/

							/*bone.rotation.setFromRotationMatrix(node.mtx);
							bone1.rotation.setFromRotationMatrix(node.mtx);
							bone2.rotation.setFromRotationMatrix(node.mtx);*/
							//if(bone.name == "Hips")bone.position.set( node.pos.x, node.pos.y, node.pos.z );
							//
							//else 
							
							/*if( bone.name==="Chest" || bone.name==="Neck" || bone.name==="Head"){
								bone.rotation.set( node.rot.x, node.rot.y, node.rot.z );
								bone1.rotation.set( node.rot.x, node.rot.y, node.rot.z );
								bone2.rotation.set( node.rot.x, node.rot.y, node.rot.z );
								//bone.rotation.set( node.rot[BVHset.ax]+(BVHset.rx*ToRad), node.rot[BVHset.ay]+(BVHset.ry*ToRad), node.rot[BVHset.az]+(BVHset.rz*ToRad) );
							}else if(bone.name==="RightUpLeg" || bone.name==="RightLowLeg" || bone.name==="RightFoot" || bone.name==="LeftUpLeg" || bone.name==="LeftLowLeg" || bone.name==="LeftFoot"){
								bone.rotation.set( (node.rot[BVHset.ax]+(BVHset.rx*ToRad))*BVHset.dx,( node.rot[BVHset.ay]+(BVHset.ry*ToRad))*BVHset.dy, (node.rot[BVHset.az]+(BVHset.rz*ToRad))*BVHset.dz );
								bone1.rotation.set( (node.rot[BVHset.ax]+(BVHset.rx*ToRad))*BVHset.dx,( node.rot[BVHset.ay]+(BVHset.ry*ToRad))*BVHset.dy, (node.rot[BVHset.az]+(BVHset.rz*ToRad))*BVHset.dz );
								bone2.rotation.set( (node.rot[BVHset.ax]+(BVHset.rx*ToRad))*BVHset.dx,( node.rot[BVHset.ay]+(BVHset.ry*ToRad))*BVHset.dy, (node.rot[BVHset.az]+(BVHset.rz*ToRad))*BVHset.dz );


							}*//*else{
								bone.rotation.set( (node.rot[BVHset.ax]+(BVHset.rx*ToRad))*BVHset.dx,( node.rot[BVHset.ay]+(BVHset.ry*ToRad))*BVHset.dy, (node.rot[BVHset.az]+(BVHset.rz*ToRad))*BVHset.dz );
								bone1.rotation.set( (node.rot[BVHset.ax]+(BVHset.rx*ToRad))*BVHset.dx,( node.rot[BVHset.ay]+(BVHset.ry*ToRad))*BVHset.dy, (node.rot[BVHset.az]+(BVHset.rz*ToRad))*BVHset.dz );
								bone2.rotation.set( (node.rot[BVHset.ax]+(BVHset.rx*ToRad))*BVHset.dx,( node.rot[BVHset.ay]+(BVHset.ry*ToRad))*BVHset.dy, (node.rot[BVHset.az]+(BVHset.rz*ToRad))*BVHset.dz );


							}*/



							bone.matrixAutoUpdate = true;
							bone.matrixWorldNeedsUpdate = true;
						}

						//
						//





						

					}
					//if(node.name == "Hips"){
					//	body.bones[0].position.set( node.pos.x, node.pos.y, node.pos.z );
					//	body.bones[0].matrixAutoUpdate = true;
			        //bone.matrixWorldNeedsUpdate = true;

					//}
				}

				/* body.bones[0].rotation.z += 90*ToRad
				  suit.bones[0].rotation.z += 90*ToRad
				   bodyShadow.bones[0].rotation.z += 90*ToRad*/

			

			}
		}

		function importHead(){
			var dir;
			if(SeaStandard){dir = 1;}
			else {dir = -1}

			var loader = new THREE.SEA3D( SeaStandard );
			var size = 0.033;
			var trace = "";

			loader.onComplete = function( e ) {

				head = loader.getMesh("skin_hi");
				head.material = materials[0];
				head.scale.set( size, size, size * dir );
				head.castShadow = head.receiveShadow = true;
				head.setWeightByName("neck", 1);

				neck = loader.getMesh("Neck");
				neck.material = materials[7];
				neck.castShadow = false;
				neck.visible = false;

				hair = loader.getMesh("Hair");
				hair.material = materials[7];
				hair.castShadow = hair.receiveShadow = true;

				eyeR = loader.getMesh("Eye_R");
				eyeR.material = materials[4];
				eyeR.castShadow = false;
				eyeR.scale.set(1,1,-1);
				eyeR.visible = false;

				eyeL = loader.getMesh("Eye_L");
				eyeL.material = materials[4];
				eyeL.castShadow = false;
				eyeL.scale.set(1,1,-1);
				eyeL.visible = false;

				// new eye
				var geometry = new THREE.IcosahedronGeometry( 18.5, 4 );
				eyeGeoL = new THREE.Mesh( geometry, materials[10] );
				eyeL.add(eyeGeoL);
				eyeGeoR = new THREE.Mesh( geometry, materials[10] );
				eyeR.add(eyeGeoR);
				eyeGeoR.rotation.z = 90*ToRad;
				eyeGeoL.rotation.z = 90*ToRad;

				eyeTop = loader.getMesh("eye_top");
				eyeTop.material = materials[5];
				eyeTop.castShadow = false;
				eyeTop.receiveShadow = false;

				teethUp = loader.getMesh("teethUpper");
				teethDown = loader.getMesh("teethLower");
				tongue = loader.getMesh("tongue");
				troat = loader.getMesh("sock");

				teethUp.material = materials[2];
				teethDown.material = materials[8];
				tongue.material = materials[3];
				troat.material = materials[6];

				teethUp.castShadow = false;
				teethDown.castShadow = false;
				tongue.castShadow = false;
				troat.castShadow = false;

				eyesTarget =  new THREE.Object3D();
				eyesTarget.position.set(0,0,50);
				scene.add( eyesTarget );

				// test if morph existe
				var mName;
				for (var j=0; j < head.geometry.morphTargets.length; j++){
					mName = head.geometry.morphTargets[j].name;
					morphsTables[mName] = { 
						tup:testMorph(teethUp, mName), 
						tdown:testMorph(teethDown, mName), 
						eye:testMorph(eyeTop, mName), 
						tongue:testMorph(tongue, mName), 
						troat:testMorph(troat, mName)
					};
				}

				scene.add( head );
				//head.play("full");
				//head.play("front");
				head.stop();


				//document.addEventListener( 'mousemove', onMouseMove, false );
				document.getElementById('loading').style.visibility = 'hidden';			
				
				//addGUIAnimation();
				addGUIMroph();

				// eye open close
				myEyeTimer = setInterval(function(){eyeActive()},5000);

				//setTimeout(function(){head.play("front");},800);

			};
			
			loader.load( 'res/models/diana_head.sea' );

		}

	


		

		function naked(){
			if(suit.visible) suit.visible = false;
			else suit.visible = true;
		}

		var tweenSequencyBobs = [];

		function bobsWalk(){
			if(animConfig.current === "walk"){
				time = 0.5;
				tweenSequencyBobs[0] = TweenLite.to(bobsAnim, 0, { low: 0, onUpdate: bobslow });	
			    tweenSequencyBobs[1] = TweenLite.to(bobsAnim, time*0.6, { low: 1, onUpdate: bobslow });
			    tweenSequencyBobs[2] = TweenLite.to(bobsAnim, time*0.4, { low: 0, delay:time*0.4, onUpdate: bobslow, onComplete:bobsWalk });

			}
		}

		function bobsMorph(value){
			body.setWeightByName("bobs", value);
			suit.setWeightByName("bobs", value);
		}

		function bobslow(){
			body.setWeightByName("low", bobsAnim.low);
			suit.setWeightByName("low", bobsAnim.low);
		}

		var normalSuit;
		var normalHead
		var normalBody;

		var textures = [];
		var texturesFiles = [
		    "body.jpg", "body_n.jpg", "head.jpg", "head_n.jpg", "suit.jpg",
		    "suit_n.jpg", "eye.jpg", "eye_n.png","hair.png", "hair_n.jpg", "eye_cont.png",
		    "sock.jpg", "teethUp.png", "teethLow.png", "tongue.jpg"


		     ]

		//-----------------------------------------------------
		//
		//  MATERIAL
		//
		//-----------------------------------------------------

		function initTextures(){
			for (var i=0, l=texturesFiles.length; i<l; i++){
				textures[i] = new THREE.ImageUtils.loadTexture( 'res/textures/diana/'+ texturesFiles[i] );
				textures[i].wrapS = textures[i].wrapT = THREE.RepeatWrapping;
				textures[i].minFilter = textures[i].magFilter = THREE.LinearFilter;
				textures[i].format = THREE.RGBFormat;
				textures[i].anisotropy = renderer.getMaxAnisotropy();
				if(i!==6 || i!==7){
					textures[i].repeat.set( 1, -1 );
					textures[i].wrapS = textures[i].wrapT = THREE.RepeatWrapping;
				} else {
					textures[i].wrapS = THREE.RepeatWrapping;
				}
			}
		}

		function initMaterial(){
			initTextures();

			var textureEnvRefl_A = new THREE.ImageUtils.loadTexture( 'res/textures/env/valley_refl_v01.jpg' );
			var textureEnvDiff_A = new THREE.ImageUtils.loadTexture( 'res/textures/env/valley_diff_v01.jpg' );
			var textureEnvBack_A = new THREE.ImageUtils.loadTexture( 'res/textures/env/valley_bg_v01.jpg' );

			

			for(var i=0; i < 10; i++){
				materials[i] = new THREE.MeshPhongMaterial({ ambient: 0x202020, specular: 0x909090, shininess: 30,
					skinning: true, morphTargets: true, morphNormals: false, 
					wrapping:THREE.ClampToEdgeWrapping, shading:THREE.SmoothShading, wrapAround:true
				});
				//materials[i] = new THREE.MeshLambertMaterial({ ambient: 0x202020, specular: 0x303030, shininess: 30, skinning: true, morphTargets: true });
				if(skyCube){
					if (i!= 2 && i!= 3 && i!= 6 && i!= 8){
						materials[i].envMap = skyCube; 
						materials[i].combine= THREE.MixOperation;
						materials[i].reflectivity=1;
					}
				}
			}

			// 0 _ head
			materials[0].map = textures[2];
			materials[0].bumpMap = textures[2];
			materials[0].bumpScale = 0.15;
			materials[0].reflectivity=0.05;
			materials[0].shininess = 14;

			// 1 _ suit
			materials[1].reflectivity=0.3;
			materials[1].shininess = 60;
			materials[1].map = textures[4];
			materials[1].bumpMap = textures[4];
			materials[1].bumpScale = 1;
			materials[1].metal = true;

			// 2 _ teeth Up
			materials[2].map = textures[12];
			materials[2].skinning = false;
			materials[2].bumpMap = textures[12];
			materials[2].bumpScale = 0.05;
			materials[2].transparent = true;

			// 3 _ tongue
			materials[3].map = textures[14];
			materials[3].skinning = false;
			materials[3].bumpMap = materials[3].map;
			materials[3].bumpScale = 0.05;

			// 4 _ null
			materials[4].morphTargets = false;
			materials[4].skinning = false;

			// 5_ eye border
			materials[5].map = textures[10];
			materials[5].skinning = false;
			materials[5].transparent = true;
			materials[5].opacity = 0.2;
			materials[5].envMap = null;
			materials[5].reflectivity=0;
			materials[5].blending = THREE[ "AdditiveAlphaBlending" ];

			// 6 _ sock
			materials[6].map = textures[11];
			materials[6].skinning = false;

			// 7 _ hair
			materials[7].map =  textures[8];
			materials[7].morphTargets = false;
			materials[7].skinning = false;
			materials[7].bumpMap =  textures[8];
			materials[7].bumpScale = 0.05;
			materials[7].transparent = true;
			materials[7].reflectivity=0.4;
			materials[7].side = THREE.DoubleSide;

			// 8 _ teeth low
			materials[8].map = textures[13];
			materials[8].skinning = false;
			materials[8].bumpMap = textures[12];
			materials[8].bumpScale = 1;
			materials[8].transparent = true;

			// 9 _ body
			materials[9].map =  textures[0];
			materials[9].bumpMap =  textures[0];
			materials[9].roughness = 0.145;
			materials[9].bumpScale = 0.15;
			materials[9].reflectivity=0.05;
			materials[9].shininess = 14;

			// 10 _ eye shader
			var eyeShader = THREE.EyeShader[ "eye" ];
			eyeShader.uniforms["texEyeCol"].value = textures[6];
			eyeShader.uniforms["texEyeNrm"].value = textures[7];
			eyeShader.uniforms["texEnvRfl"].value = textureEnvRefl_A;
			eyeShader.uniforms["texEnvDif"].value = textureEnvDiff_A;

			materials[10] = new THREE.ShaderMaterial({ 
				uniforms: eyeShader.uniforms,
				vertexShader: eyeShader.vertexShader,
				fragmentShader: eyeShader.fragmentShader
			});

			// 11 _ skin shader
			var skinShader = THREE.ShaderSkin[ "skin" ];
			var uniformsUV = THREE.UniformsUtils.clone( skinShader.uniforms );
			uniformsUV[ "tNormal" ].value = textures[1];//THREE.ImageUtils.loadTexture( "obj/leeperrysmith/Infinite-Level_02_Tangent_SmoothUV.jpg" );
			uniformsUV[ "uNormalScale" ].value = 0.75;
			uniformsUV[ "tDiffuse" ].value = textures[0];//THREE.ImageUtils.loadTexture( "obj/leeperrysmith/Map-COL.jpg" );
			uniformsUV[ "passID" ].value = 0;
			uniformsUV[ "diffuse" ].value.setHex( 0xbbbbbb );
			uniformsUV[ "specular" ].value.setHex( 0x070707 );
			uniformsUV[ "ambient" ].value.setHex( 0x111111 );
			uniformsUV[ "uRoughness" ].value = 0.185;
			uniformsUV[ "uSpecularBrightness" ].value = 0.8;

			var uniforms = THREE.UniformsUtils.clone( uniformsUV );
			uniforms[ "tDiffuse" ].value = uniformsUV[ "tDiffuse" ].value;
			uniforms[ "tNormal" ].value = uniformsUV[ "tNormal" ].value;
			uniforms[ "passID" ].value = 1;

			var parameters = { fragmentShader: skinShader.fragmentShader, vertexShader: skinShader.vertexShader, uniforms: uniforms, lights: true, skinning: true, morphTargets: true };
			var parametersUV = { fragmentShader: skinShader.fragmentShader, vertexShader: skinShader.vertexShaderUV, uniforms: uniformsUV, lights: true };


			materials[11] = new THREE.ShaderMaterial( parameters );
			materials[12] = new THREE.ShaderMaterial( parametersUV );





			for(var i=0, l = materials.length; i < l; i++){
				materials[i].needsUpdate = true;
			}

		}

		function switchMaterialMethod(){
			if(viewConfig.withBump){
				viewConfig.withBump = false;
				viewConfig.withNormal = true;

				materials[0].bumpMap = null;
			    materials[0].bumpScale = 0;

			    materials[1].bumpMap = null;
			    materials[1].bumpScale = 0;

			    materials[9].bumpMap = null;
			    materials[9].bumpScale = 0;

			    materials[0].normalMap = textures[3];
			    materials[0].normalScale={x:1,y:1};
			    materials[1].normalMap = textures[5];
			    materials[1].normalScale={x:1,y:1};
			    materials[9].normalMap = textures[1];
			    materials[9].normalScale={x:1,y:1};

			} else {
				viewConfig.withBump = true;
				viewConfig.withNormal = false;

				materials[0].normalMap = null;
			    materials[0].normalScale={x:0,y:0};
			    materials[1].normalMap = null;
			    materials[1].normalScale={x:0,y:0};
			    materials[9].normalMap = null;
			    materials[9].normalScale={x:0,y:0};

				materials[0].bumpMap = textures[2];
			    materials[0].bumpScale = 0.15;

			    materials[1].bumpMap = textures[4];
			    materials[1].bumpScale = 1;

			    materials[9].bumpMap = textures[0];
			    materials[9].bumpScale = 0.15;
			}
			materials[0].needsUpdate = true;
			materials[1].needsUpdate = true;
			materials[9].needsUpdate = true;
		}

		

		//-----------------------------------------------------
		//  MULTY MORPH
		//-----------------------------------------------------

		function fullMorph( name , value) {
			if(!morphsTables[name])return;
			 head.setWeightByName(name, value);
			if( morphsTables[name].tup ) teethUp.setWeightByName(name, value);
			if( morphsTables[name].tdown ) teethDown.setWeightByName(name, value);
			if( morphsTables[name].eye ) eyeTop.setWeightByName(name, value);
			if( morphsTables[name].tongue ) tongue.setWeightByName(name, value);
			if( morphsTables[name].troat ) troat.setWeightByName(name, value);
		}

		function testMorph(m, name){
			var result = false;
			for (var j=0; j < m.geometry.morphTargets.length; j++){
				if(m.geometry.morphTargets[j].name == name) result = true;
			}
			return result;
		}



		//-----------------------------------------------------
		//  EYE
		//-----------------------------------------------------
		var eyeControl = { control:0 }

		function eyeActive(){
			var time = 0.300;
			tweenSequencyEye[0] = TweenLite.to(eyeControl, 0, { control: 0, onUpdate: eyeUpdate });	
			tweenSequencyEye[1] = TweenLite.to(eyeControl, time*0.6, { control: 1, onUpdate: eyeUpdate });
			tweenSequencyEye[2] = TweenLite.to(eyeControl, time*0.4, { control: 0, delay:time*0.4, onUpdate: eyeUpdate });

			/*tweenSequencyEye[0] = new TWEEN.Tween( {  control: 0 }  ).to( { control: 1 } , time*0.6 ).easing( TWEEN.Easing.Linear.None )
			tweenSequencyEye[1] = new TWEEN.Tween( {  control: 1 }  ).to( { control: 0 } , time*0.4 ).easing( TWEEN.Easing.Linear.None ).delay(time*0.6);

			tweenSequencyEye[0].onUpdate(function(){
				fullMorph( "blinkRight" , this.control); 
				fullMorph( "blinkLeft" , this.control);
				});
			tweenSequencyEye[1].onUpdate(function(){
				fullMorph( "blinkRight" , this.control); 
				fullMorph( "blinkLeft" , this.control); 
				});
			tweenSequencyEye[0].start();
			tweenSequencyEye[1].start();*/
		}

		function eyeUpdate(){
			fullMorph( "blinkRight" , eyeControl.control); 
			fullMorph( "blinkLeft" , eyeControl.control);
		}

		/*function hairActive(){
			var time = 3000;
			tweenSequencyHair[0] = new TWEEN.Tween( {  control: 0 }  ).to( { control: 1 } , time*0.5 ).easing( TWEEN.Easing.Linear.None )
			tweenSequencyHair[1] = new TWEEN.Tween( {  control: 1 }  ).to( { control: 0 } , time*0.5 ).easing( TWEEN.Easing.Linear.None ).delay(time*0.5);

			tweenSequencyHair[0].onUpdate(function(){
					hair.setWeightByName("Hair001", this.control );
				});
			tweenSequencyHair[1].onUpdate(function(){
					hair.setWeightByName("Hair001", this.control );
				});
			tweenSequencyHair[0].start();
			tweenSequencyHair[1].start();
		}*/


		//-----------------------------------------------------
		//  SPEAK JS OR GOOGLE TRADUCTION
		//-----------------------------------------------------

		function say() {
			if(voiceConfig.googleVoise){
				sayIt(imput.value);
				//testWithPHP();
			} else {
				timeWav=0;
				timeProcess=0;
				timeComplete = 0;
				isSongTest = true;
				speak(text, voiceConfig );
			}
		}

		// test if sound is ready if use speak.js
		function songReady(){

			timeWav=parseFloat(document.getElementById('timeWav').innerHTML);
			timeProcess=parseFloat(document.getElementById('timeProcess').innerHTML);
			timeComplete = parseFloat(document.getElementById('timeComplete').innerHTML);

			if(timeWav != 0 && timeProcess != 0 && timeComplete == 1){ 
				//tell( 'wav:'+timeWav + "ms | worker process:" + timeProcess+'ms');
				var tt = (timeWav+timeProcess);
				tell('speak js finaltime: ' + tt + ' ms');
				processTimer = setInterval(function(){startSequence()}, tt);
				isSongTest = false; 
			}
		}

		function countWords(){

			if( output.childNodes.length > 0 ){
				if(output.innerHTML != oldOutput.innerHTML){
					phonemesSequency = [];
					for(var i=0; i< output.childNodes.length; i++){
						if(output.childNodes[i].nodeName=="#text") convert(0);
						else if(output.childNodes[i].nodeName=="SPAN") convert( output.childNodes[i].textContent );
					}
					if(phonemesSequency.length>0){
						text = imput.value;
						playButton.style.visibility = 'visible';
						tell( "seq: " + phonemesSequency );
					}
					else playButton.style.visibility = 'hidden';

					oldOutput.innerHTML = output.innerHTML;
				}
			}
		}

		// Phonemes
		function convert(n) {
			if(n==0)phonemesSequency.push(n);
			else {
				var ph = n.split(' ');
				var num = 1;
				for (var i=0;i<ph.length;i++){
					switch ( ph[i] ) {
						case 'HH': num = 3; break;
						case 'AH0': num = 1; break;
						case 'AH1': num = 1; break;
						case 'AY1': num = 5; break;
						case 'AY2': num = 5; break;
						case 'L': num = 15; break;
						case 'W': num = 14; break;
						case 'ER1': num = 11; break;
						case 'ER0': num = 11; break;
						case 'D': num = 12; break;
						case 'M': num = 8; break;
						case 'EY1': num = 7; break;
						case 'EH1': num = 7; break;
						case 'IH1': num = 5; break;
						case 'IH0': num = 5; break
						case 'IY1': num = 5; break;
						case 'Z': num = 12; break;
						case 'F': num = 4; break;
						case 'K': num = 6; break;
						case 'B': num = 8; break;
						case 'R': num = 11; break;
						case 'Y': num = 15; break;
						case 'TH': num = 13; break;
						case 'S': num = 12; break;
						case 'T': num = 13; break;
						case 'G': num = 6; break;
						case 'OW1': num = 10; break;
						case 'OY1': num = 10; break;
						case 'UW1': num = 14; break;
						case 'V': num = 4; break;
						case 'JH': num = 3; break;
						case 'P': num = 8; break;
					}
					phonemesSequency.push(num);
				}
			}
		}

		// Phonemes morph possibility
		function phonemeNumber(Value) {
			var t;
			switch ( Value ) {
				case 0: t = ''; break;
				case 1: t = 'aah'; break;
				case 2: t = 'bigaah'; break;
				case 3: t = 'ch.j.sh'; break;
				case 4: t = 'f.v'; break;
				case 5: t = 'i'; break;
				case 6: t = 'k'; break;
				case 7: t = 'ee'; break;
				case 8: t = 'b.m.p'; break;
				case 9: t = 'n'; break;
				case 10: t = 'oh'; break;
				case 11: t = 'r'; break;
				case 12: t = 'd.s.t'; break;
				case 13: t = 'th'; break;
				case 14: t = 'w'; break;
				case 15: t = 'eh'; break;
				case 16: t = 'ooh.q'; break;
			}
			return t;
		}

		function startSequence(){
			clearInterval(processTimer);
			sequencyPlay();
		}

		function sequencyPlay(){
			tweenSequencyStart = [];
			tweenSequencyOpen = [];
			tweenSequencyClose = [];
			var time = 0.1;//100;
			var t0 = time*0.75;
			var t1 = time*0.25;

			for (var i=0; i< phonemesSequency.length; i++){
				tweenSequencyStart[i] = TweenLite.to(seq, 0, { phoneme:phonemesSequency[i], control: 0, delay:(i*time), onUpdate: sequencyUpdate });	
				tweenSequencyOpen[i] = TweenLite.to(seq, t0, { phoneme:phonemesSequency[i], control: 1, delay:(i*time), onUpdate: sequencyUpdate });
				tweenSequencyClose[i] = TweenLite.to(seq, t1, { phoneme:phonemesSequency[i], control: 0, delay:(i*time + t0), onUpdate: sequencyUpdate });


				/*tweenSequencyOpen[i] = new TWEEN.Tween( { phoneme:phonemesSequency[i], control: 0 }  ).to( {phoneme:phonemesSequency[i], control: 0.8 } , time*0.75 ).easing( TWEEN.Easing.Linear.None ).delay(i*time);
				tweenSequencyClose[i] = new TWEEN.Tween( { phoneme:phonemesSequency[i], control: 0.8 }  ).to( {phoneme:phonemesSequency[i], control: 0 } , time*0.25 ).easing( TWEEN.Easing.Linear.None ).delay(i*time + time*0.75);

				tweenSequencyOpen[i].onUpdate(function(){ fullMorph( phonemeNumber(this.phoneme) , this.control); });
				tweenSequencyClose[i].onUpdate(function(){ fullMorph( phonemeNumber(this.phoneme) , this.control); });
				tweenSequencyOpen[i].start();
				tweenSequencyClose[i].start();*/
			}
		}

		function sequencyUpdate(){
			fullMorph( phonemeNumber(seq.phoneme) , seq.control);
		}

		//-----------------------------------------------------
		//  GUI
		//-----------------------------------------------------

		function addGUI() {
			gui = new dat.GUI({autoPlace:false, width:204});
			document.getElementById('gui').appendChild(gui.domElement);
			//gui.close();
		}

		function addGUIView() {
			var f4 = gui.addFolder('View Option');
			f4.add( viewConfig, 'antialias' ).onChange( function() { renderer.antialias = viewConfig.antialias});
			f4.add( viewConfig, 'withEffect' ).onChange( function() {//initComposer();
			});
			f4.add( viewConfig, 'withBump' ).listen().onChange( function() {switchMaterialMethod();});
			f4.add( viewConfig, 'withNormal' ).listen().onChange( function() {switchMaterialMethod();});

			
		}

		function addGUIAnimation() {	
			var f0 = gui.addFolder('Animation');

			f0.add( viewConfig, 'squeleton' ).listen().onChange( function() {modelOrBones();});
			f0.add( viewConfig, 'headMove' );

           animConfig.idle = function() { playAnimation("idle"); };
           animConfig.walk = function() { playAnimation("walk"); };
           animConfig.salut = function() { playAnimation("tell"); };

            f0.add( animConfig, 'idle' );
			f0.add( animConfig, 'walk' );
			f0.add( animConfig, 'salut' );

			f0.add( animConfig, 'speed', 0.1, 1 );

			f0.open();
		}

		function addGUIMroph() {
			var f1 = gui.addFolder('Morph');

			f1.add( morphConfig, 'automove' ).onChange( function() {
				if(!morphConfig.automove){
					fullMorph("smileOpen", 0);
					fullMorph("fear", 0);
				} 
			});
			f1.add( morphConfig, 'naked' ).onChange( function() { naked(); });
			f1.add( morphConfig, 'bobs', 0, 100 ).onChange( function() { bobsMorph( morphConfig.bobs/100); });

			f1.add( morphConfig, 'sadness', 0, 100 ).onChange( function() { fullMorph("sad", morphConfig.sadness/100); });
			f1.add( morphConfig, 'anger', 0, 100 ).onChange( function() { fullMorph("anger", morphConfig.anger/100); });
			f1.add( morphConfig, 'joy', 0, 100 ).onChange( function() { fullMorph("smileOpen", morphConfig.joy/100); });
			f1.add( morphConfig, 'fear', 0, 100 ).onChange( function() { fullMorph("fear", morphConfig.fear/100); });
			f1.add( morphConfig, 'disgust', 0, 100 ).onChange( function() { fullMorph("disgust", morphConfig.disgust/100); });
			f1.add( morphConfig, 'surprise', 0, 100 ).onChange( function() { fullMorph("surprise", morphConfig.surprise/100); });

			var f2 = gui.addFolder('Phonemes');
			f2.add( morphConfig, 'aah', 0, 100 ).listen().onChange( function() {fullMorph("aah", morphConfig.aah/100);});
			f2.add( morphConfig, 'bigaah', 0, 100 ).listen().onChange( function() { fullMorph("bigaah", morphConfig.bigaah/100);});
			f2.add( morphConfig, 'ch_j_sh', 0, 100 ).listen().onChange( function() { fullMorph("ch.j.sh", morphConfig.ch_j_sh/100);});
			f2.add( morphConfig, 'f_v', 0, 100 ).listen().onChange( function() { fullMorph("f.v", morphConfig.f_v/100);});
			f2.add( morphConfig, 'i', 0, 100 ).listen().onChange( function() { fullMorph("i", morphConfig.i/100);});
			f2.add( morphConfig, 'k', 0, 100 ).listen().onChange( function() { fullMorph("k", morphConfig.k/100);});
			f2.add( morphConfig, 'ee', 0, 100 ).listen().onChange( function() { fullMorph("ee", morphConfig.ee/100);});
			f2.add( morphConfig, 'b_m_p', 0, 100 ).listen().onChange( function() { fullMorph("b.m.p", morphConfig.b_m_p/100);});
			f2.add( morphConfig, 'n', 0, 100 ).listen().onChange( function() { fullMorph("n", morphConfig.n/100);});
			f2.add( morphConfig, 'oh', 0, 100 ).listen().onChange( function() { fullMorph("oh", morphConfig.oh/100);});
			f2.add( morphConfig, 'r', 0, 100 ).listen().onChange( function() { fullMorph("r", morphConfig.r/100);});
			f2.add( morphConfig, 'd_s_t', 0, 100 ).listen().onChange( function() { fullMorph("d.s.t", morphConfig.d_s_t/100);});
			f2.add( morphConfig, 'th', 0, 100 ).listen().onChange( function() { fullMorph("th", morphConfig.th/100);});
			f2.add( morphConfig, 'w', 0, 100 ).listen().onChange( function() { fullMorph("w", morphConfig.w/100);});
			f2.add( morphConfig, 'eh', 0, 100 ).listen().onChange( function() { fullMorph("eh", morphConfig.eh/100);});
			f2.add( morphConfig, 'ooh_q', 0, 100 ).listen().onChange( function() {fullMorph("ooh.q", morphConfig.ooh_q/100);});

			//f2.open();
			//f1.open();
			addGUIEye();
		}

		function addGUIEye() {

		    var guiEyeProp = gui.addFolder('Eye properties');
			
			guiEyeProp.add( eyeController, "pupil_size", 			0.0, 1.0 ).name('Pupil size').onChange( matChanger );
	//		guiEyeProp.add( eyeController, "iris_tex_start",		0.0, 1.0 ).name('Iris V start').onChange( matChanger );
	//		guiEyeProp.add( eyeController, "iris_tex_end", 			0.0, 1.0 ).name('Iris V end').onChange( matChanger );
			guiEyeProp.add( eyeController, "iris_size", 			0.0, 1.0 ).name('Iris size').onChange( matChanger );
			guiEyeProp.add( eyeController, "iris_edge_fade", 		0.0, 1.0 ).name('Iris edge fade').onChange( matChanger );
			guiEyeProp.add( eyeController, "iris_inset_depth", 		0.0, 1.0 ).name('Iris edge inset').onChange( matChanger );
			guiEyeProp.add( eyeController, "sclera_tex_scale", 		-1.0, 1.0 ).name('Sclera texture size').onChange( matChanger );
			guiEyeProp.add( eyeController, "sclera_tex_offset", 	0.0, 1.0 ).name('Sclera texture offset').onChange( matChanger );
			guiEyeProp.add( eyeController, "ior", 					1.01, 2.0 ).name('Cornea IOR').onChange( matChanger );
	//		guiEyeProp.add( eyeController, "refract_edge_softness", 0.0, 1.0 ).name('Refract edge softness').onChange( matChanger );
			guiEyeProp.add( eyeController, "iris_texture_curvature", 		0.001, 1.0 ).name('Iris texture curvature').onChange( matChanger );
			guiEyeProp.add( eyeController, "arg_iris_shading_curvature", 	0.001, 1.0 ).name('Iris shading curvature').onChange( matChanger );
			guiEyeProp.add( eyeController, "tex_U_offset", 			0.0, 1.0 ).name('Texture U offset').onChange( matChanger );
			guiEyeProp.add( eyeController, "iris_border", 			0.0, 1.0 ).name('Texture V offset').onChange( matChanger );
			guiEyeProp.add( eyeController, "cornea_bump_amount", 	0.0, 0.2 ).name('Cornea bulging').onChange( matChanger );
			guiEyeProp.add( eyeController, "cornea_bump_radius_mult",0.0, 2.0 ).name('Cornea radius scale').onChange( matChanger );
			guiEyeProp.add( eyeController, "iris_normal_offset", 	0.0, 1.0 ).name('Iris shading offset').onChange( matChanger );
			guiEyeProp.add( eyeController, "cornea_density", 		0.0, 1.0 ).name('Cornea clouding').onChange( matChanger );
			guiEyeProp.add( eyeController, "bump_texture", 			-1.0, 1.0 ).name('Bump texture').onChange( matChanger );
			guiEyeProp.add( eyeController, "catshape" ).name('Cat eye shape').onChange( matChanger );
			guiEyeProp.close();
			
		}

		var matChanger = function( ) {
			for (var e in eyeController) {
				if (e in materials[10].uniforms)
				materials[10].uniforms[ e ].value = eyeController[ e ];
			}
		}

		function addGUIVoise() {

			var f3 = gui.addFolder('Voise');

			f3.add( voiceConfig, 'googleVoise' ).onChange( function() {});

			f3.add( voiceConfig, 'rate', 0, 300 ).onChange( function() { synthesis.rate = voiceConfig.rate/100 });
			/*f3.add( voiceConfig, 'wordgap', 0, 100 ).onChange( function() {});
			f3.add( voiceConfig, 'pitch', 0, 400 ).onChange( function() {});
			f3.add( voiceConfig, 'speed', 0, 400 ).onChange( function() {});*/

			//f3.open();

			
		}

		function toRad(Value) {
			return Value * Math.PI / 180;
		}
		
		function tell(s){
			document.getElementById("debug").innerHTML = s;
		}

		//-----------------------------------------------------
		//  GOOGLE SPEAK
		//-----------------------------------------------------
		
		var synthesis;
		function sayIt(query, language) {
		    synthesis = new SpeechSynthesisUtterance(query);
		    synthesis.lang = language || 'en-US';
		    synthesis.rate = voiceConfig.rate;
		    speechSynthesis.speak(synthesis);
		    sequencyPlay();
		}

		//-----------------------------------------------------
		//  GOOGLE SPEAK TRADUCTION WITH PHP
		//-----------------------------------------------------
		

		/*function testWithPHP(){

			var fd = new FormData();
			fd.append("txt", text);

			var xhr = new XMLHttpRequest();
			xhr.addEventListener("load", uploadComplete, false);
			xhr.addEventListener("error", uploadFailed, false);
			xhr.addEventListener("abort", uploadCanceled, false);
			xhr.open("POST", "tts.php", true);
			xhr.onreadystatechange = function (evt) {
				if (this.readyState === 4) {
					if (this.status == 200) {
						tell( xhr.responseText);
						// start animation
						processTimer = setInterval(function(){startSequence()}, 10);
					}
				}
			};
			xhr.send(fd);

		}

		function uploadComplete(evt){
			//alert(evt.target.);
		}

		function uploadFailed(evt){
			tell("error !!");
		}

		function uploadCanceled(evt){
			tell("upload cancel");
		}*/

		//-----------------------------------
		// MATH
		//-----------------------------------

		function Orbit(origine, horizontal, vertical, distance) {
		    var p = new THREE.Vector3();
		    var phi = vertical*ToRad;
		    var theta = horizontal*ToRad;
		    p.x = (distance * Math.sin(phi) * Math.cos(theta)) + origine.x;
		    p.z = (distance * Math.sin(phi) * Math.sin(theta)) + origine.z;
		    p.y = (distance * Math.cos(phi)) + origine.y;
		    return p;
		}

		//-----------------------------------
		// MOUSE & NAVIGATION 
		//-----------------------------------

		var changeView = function (h, v, d) {
			TweenLite.to(camPos, 3, {horizontal: h, vertical: v, distance: d, onUpdate: moveCamera });
			camPos.automove = true;
		}

		function moveCamera() {
		    camera.position.copy(Orbit(center, camPos.horizontal, camPos.vertical, camPos.distance));
		    camera.lookAt(center);
		}

		function onMouseDown(e) {
		    e.preventDefault();
		    mouse.ox = e.clientX;
		    mouse.oy = e.clientY;
		    mouse.h = camPos.horizontal;
		    mouse.v = camPos.vertical;
		    mouse.down = true;
		}

		function onMouseUp(e) {
		    mouse.down = false;
		    document.body.style.cursor = 'auto';
		}

		function onMouseMove(e) {
		    e.preventDefault();
		    if (mouse.down ) {
		        document.body.style.cursor = 'move';
		        if(SeaStandard)camPos.horizontal = (-(e.clientX - mouse.ox) * 0.3) + mouse.h;
		        else camPos.horizontal = ((e.clientX - mouse.ox) * 0.3) + mouse.h;
		        camPos.vertical = (-(e.clientY - mouse.oy) * 0.3) + mouse.v;

		        moveCamera();
		    } else {
		    	mouse.ox = e.clientX;
			    mouse.oy = e.clientY;
		    	onMouseMoveExtra();
		    }
		}

		function onMouseWheel(e) {
		    var delta = 0;
		    if(e.wheelDelta){delta=e.wheelDelta*-1;}
		    else if(e.detail){delta=e.detail*20;}
		    camPos.distance+=(delta/10);
		    
		    if(camPos.distance<=100){
		    	if( center.y <= 26) center.y = (100-camPos.distance)/3.3;
		    	else center.y = 26;
		    }else{
		    	center.y = 0;
		    }

		    moveCamera();   
		    e.preventDefault();
		}

		window.onload = init;

		//-----------------------------------
		// NAVIGATOR DETECT
		//-----------------------------------

		ua = function() {
			var ua  = navigator.userAgent.toLowerCase();
			var key =        ((ua.indexOf("opera")   > -1) ? "opera"   : null);
			    key = key || ((ua.indexOf("firefox") > -1) ? "firefox" : null);
			    key = key || ((ua.indexOf("chrome")  > -1) ? "chrome"  : null);
			    key = key || ((ua.indexOf("safari")  > -1) ? "safari"  : null);
			    key = key || ((ua.indexOf("msie")    > -1) ? "ie"      : null);
			try {
			    var re      = (key == "ie") ? "msie ([\\d\\.]*)" : key + "\\/([\\d\\.]*)";
			    var matches = ua.match(new RegExp(re, "i"));
			    var version = matches ? matches[1] : null;
			} catch (e){}
			return {
			    full:ua, name:key + (version ? " " + version : ""), version:version, major:version ? parseInt(version) : null,
			    is: { firefox:(key == "firefox"), chrome:(key == "chrome"), safari:(key == "safari"), opera:(key == "opera"), ie:(key == "ie")}
			}
		}();

	</script>

	<body>
		<div id="viewport"></div>
		<div id="hubs">
			<div id="debug"></div>
			<div id="guiContener"><div id="gui"></div></div>
			<div id="copy">
				Diana v0.2.5 <a href="http://3dflashlo.wordpress.com/" target="_blank">&nbsp;&nbsp;&nbsp;loth 2014&nbsp;&nbsp;&nbsp;</a>
				<a href="http://github.com/mrdoob/three.js" target="_blank">three.js</a> 
				. <a href="https://code.google.com/p/sea3d/" target="_blank">sea3d</a> 
				. <a href="https://github.com/kripken/speak.js/" target="_blank"> speak.js</a> 
				. <a href="https://github.com/dzucconi/phoneme-client" target="_blank"> phoneme-client</a>
				. <a href="http://vill.ee/eye/" target="_blank"> eye shader</a>
			</div>
			<div id="loading"><img src="res/img/loader.gif" alt="Loading SEA3D File."></div>
		</div>
		<div id="timeWav" style="visibility: hidden;"></div>
		<div id="timeProcess" style="visibility: hidden;"></div>
		<div id="timeComplete" style="visibility: hidden;"></div>
		
		<div id="bub"><img class="bulle" src="res/img/bulle.png" /></div>
		
		<div class="cell-editor"><textarea id="editor" autofocus="true" placeholder="Begin typing"></textarea></div>
		
		<div id="stage" class="cell-stage">

			<div id="output"></div>
			<div id="loader" class="loading-indicator"><img src="res/img/loader_mini.gif" alt="Loading text"></div>
			<div id="oldOutput" style="visibility:hidden;">X</div>

		</div>
		<div id="play"> <img class="buttonPlay" src="res/img/soundw.png" alt="play sound" onclick="say();" /></div>

		<div id="output2"></div>
		

	</body>
</html>